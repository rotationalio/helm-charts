# Default values for Compass.
# Declare your specific configuration values in a YAML file and pass it to helm install using the --values flag.

# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

# The number of replicas to run for the Compass deployment.
# NOTE: this chart does not allow for autoscaling at this time.
replicaCount: 1

image:
  repository: rotationalio/compass
  pullPolicy: Always
  tag: ""

imagePullSecrets: []

# Compass specific configuration.
compass:
  django:
    debug: false
    settingsModule: "compass.settings.production"

  allowedHosts: []

  inference:
    endpoint: "https://openrouter.ai/api/v1"
    transcriptionModel: "google/gemini-2.5-flash"

  audio:
    uploadDirectory: "/data/audio"
    maxAudioFiles: -1

  domain:
    default: "Cross-Industry Business Operations"
    useGeneratedDomain: true

  endeavor:
    endpoint: "https://guidelight.dev"
    authEndpoint: "https://auth.guidelight.dev/v1/authenticate"

  sentry:
    dsn: ""

# Web application secrets can be created by the chart (not recommended) by setting the
# create flag to true (note that the secretName will not be used in this case).
# Otherwise, specify the secretName and secretKey rather than a value for each secret
# item and create the secret(s) manually before helm installing the chart.
secrets:
  create: true # set to false to use a pre-installed secret instead

  # This is the Django secret key used for cryptographic signing.
  secretKey:
    secretName: ""
    secretKey: secretKey
    value: ""

  # Because the database URL contains a password, it is considered a secret.
  databaseURL:
    secretName: ""
    secretKey: databaseURL
    value: ""

  # The default admin password to create if the ensureAdmin job is enabled.
  adminPassword:
    secretName: ""
    secretKey: adminPassword
    value: ""

  # The OpenRouter API Key to use for inference requests.
  openRouterAPIKey:
    secretName: ""
    secretKey: openRouterAPIKey
    value: ""

  # The Endeavor API Client Secret to use for authenticating requests to Endeavor.
  endeavorClientID:
    secretName: ""
    secretKey: endeavorClientID
    value: ""

  endeavorClientSecret:
    secretName: ""
    secretKey: endeavorClientSecret
    value: ""

# Jobs that can be configured to run in Compass to migrate the database or ensure
# an admin user is created with the specified adminPassword.
jobs:
  migrate:
    create: true
    backoffLimit: 3
  ensureAdmin:
    create: true
    username: admin
    email:
    backoffLimit: 3

# Specify how pods are created in the deployment.
pod:
  # Add additional annotations to the pods
  annotations: {}

  # Add additional labels to the pods
  labels: {}

  # Specify a pod security context
  securityContext: {}

# Optionally specify the security context of the container.
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  name: ""
  className: ""
  annotations: {}
  hosts:
    - host: compass.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# The liveness probe requires Compass to be running.
livenessProbe:
  httpGet:
    path: /livez
    port: 8000
    httpHeaders:
    - name: X-Kubernetes-Probe
      value: liveness
  initialDelaySeconds: 2
  periodSeconds: 10

# The readiness probe requires Compass to be running and connected to the database.
readinessProbe:
  httpGet:
    path: /readyz
    port: 8000
    httpHeaders:
    - name: X-Kubernetes-Probe
      value: readiness
  initialDelaySeconds: 2
  periodSeconds: 10

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# Optionally specify how nodes are selected to place pods on.
nodeSelector: {}

# Optionally specify tolerations to ensure pods are not scheduled on incompatible nodes.
tolerations: []

# Optionally specify affinities to ensure pods and resources are together or apart.
affinity: {}